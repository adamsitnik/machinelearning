// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Toolchains;
using BenchmarkDotNet.Toolchains.CsProj;
using System;
using System.IO;
using System.Linq;

namespace Microsoft.ML.Benchmarks.Harness
{
    /// <summary>
    /// to avoid side effects of benchmarks affect each other BenchmarkDotNet runs every benchmark in a standalone, dedicated process
    /// however to do that it needs to be able to create, build and run new executable
    /// 
    /// the problem with ML.NET is that it has native dependencies, which are NOT copied by MSBuild to the output folder
    /// in case where A has native dependency and B references A
    /// 
    /// this is why this class exists: to copy the native dependencies to folder with .exe
    /// </summary>
    public class ProjectGenerator : CsProjGenerator
    {
        public ProjectGenerator(string targetFrameworkMoniker) : base(targetFrameworkMoniker, platform => platform.ToConfig(), null)
        {
        }

        protected override void GenerateNuGetConfig(ArtifactsPaths artifactsPaths)
        {
            // BDN ignores Directory.Build.props file which in case of ML.NET contains the NuGet feeds
            // so we need a nuget.config file to be able to restore "mlnetmkldeps" dependency
            File.WriteAllText(artifactsPaths.NuGetConfigPath,
@"<?xml version=""1.0"" encoding=""utf-8""?>
<configuration>
 <packageSources>
    <clear />
    <add key=""nuget"" value=""https://api.nuget.org/v3/index.json"" />
    <add key=""net core"" value="" https://dotnet.myget.org/F/dotnet-core/api/v3/index.json"" />
 </packageSources>
</configuration>");
        }

        protected override void CopyAllRequiredFiles(ArtifactsPaths artifactsPaths)
        {
            base.CopyAllRequiredFiles(artifactsPaths);

            CopyMissingNativeDependencies(artifactsPaths);
        }

        private void CopyMissingNativeDependencies(ArtifactsPaths artifactsPaths)
        {
            var foldeWithAutogeneratedExe = Path.GetDirectoryName(artifactsPaths.ExecutablePath);
            var folderWithNativeDependencies = Path.GetDirectoryName(typeof(ProjectGenerator).Assembly.Location);

            foreach (var nativeDependency in Directory
                .EnumerateFiles(folderWithNativeDependencies)
                .Where(fileName => ContainsWithIgnoreCase(fileName, "native")))
            {
                File.Copy(
                    sourceFileName: nativeDependency,
                    destFileName: Path.Combine(foldeWithAutogeneratedExe, Path.GetFileName(nativeDependency)), 
                    overwrite: true);
            }
        }

        bool ContainsWithIgnoreCase(string text, string word) => text != null && text.IndexOf(word, StringComparison.InvariantCultureIgnoreCase) >= 0;
    }
}
